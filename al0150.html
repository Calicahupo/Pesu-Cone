<!DOCTYPE html>
<html><head>
<meta http-equiv="content-type" content="text/html; charset=utf-8">
		<title>Aldiode 150</title>
		<style>

		@font-face { font-family:'profont';
			src:url('AL_files/profontwindows-webfont.woff2') format('woff2'),
				url('AL_files/profontwindows-webfont.woff') format('woff');
			font-weight:normal; font-style:normal; }
		@font-face { font-family: 'strike_fighter';
    		src:url('AL_files/strikefighter-webfont.woff2') format('woff2'),
         		url('AL_files/strikefighter-webfont.woff') format('woff');
    		font-weight: normal; font-style: normal; }
		html,body { height:100%; margin:0px; font-family:profont; font-size:13px; }
		.topLeft { top:0px; left:0px; }	.topRight{ top:0px; right:0px;}
		.absolute { position:absolute; } .half { width: 50%; } .left { float:left; } .right{ float:right;}
		.cell { position:relative; color: red; }


		.personInHeader { position: relative; float:left; margin: 0px 2px; padding: 0px 2px; background-color: rgba(0,0,0,0.1618); height: 100%; -webkit-border-radius: 8px; -moz-border-radius: 8px; border-radius: 8px; }
		.avatarInHeader { display:inline-block; position:relative; margin: 0px 5px 0px 2px; padding: 0px 5px; top:5px; text-align:center; }
		.gender { position:absolute; margin-left: -5px; padding-top: 4px; }
		.genderX{ position:absolute; right:0px; }
		.genderx{ position:absolute; left:0px; }
		.genderY{ position:absolute; width:inherit; text-align:center; }
		.gendery{ position:absolute; bottom:0px; width:inherit; text-align:center; }
		.setting { float: right; }
		.cell { font-family:strike_fighter; text-align:right; }
		.cellValue { width:inherit; position:absolute; }
		.cellPieces { position:absolute; font-family:profont; width:auto; }
		.avatar { position:absolute; }
		.avatarInTurn { text-shadow: 0 0 5px #fff, 0 0 10px #fff, 0 0 20px #ff0080, 0 0 30px #ff0080, 0 0 40px #ff0080, 0 0 55px #ff0080, 0 0 75px #ff0080; }
		#wrapper { min-height:100%; background-color:black; }
		#header { background-color:#888; width: 100%; }
		#content { background-color:black; }
		.contentLeft { width: 50%; }

		</style>
		<script src="AL_files/jquery-2.js"></script>
		<script src="AL_files/underscore-min.js"></script>
		<script src="AL_files/three.min.js"></script>
		<script src="AL_files/aldiode-data.js"></script>
		<script>//white glow on increased quality, black on decreased. in tables, later
		// The Slavs appear to have a most genuine desire to be human, which is rare among whites.
		// A woman measures her charisma according to how permitted it is for her to be like a man.
		// Could objectivity as a mindset be interpreted as activity motivated by avoidance of stress?
		// When punishing unfamiliar women, always choose multiple targets.
		// For women it holds that there's an upper limit to beneficiality of attractiveness if that is measured as proportions of face and body and attractive movements. Once one doesn't need to change own conditioning to adult conditioning because one is so attractive in comparison to one's willpower, this kind of attractivity begins precluding more forms of excellence than it facilitates. This doesn't apply to men as much because external factors of appearance that are known to indicate masculinity are less relevant for finding a devoted partner.
		// Any pleasure a woman provides to another man as herself is pure evil from the viewpoint of other women? Revise current theories considering quality and otherness
/*		Abstract:	Tangible:	Both:
Element:Event		Thing		Issue
Set:	Context 	Situation	Circumstance
Both:	Abstract	Tangible	Pattern*/
var AL = {
	//UI
	tab:		"mosaic",		tabs:		["mosaic"],
	demo:		false,			dev:		false,			devHeader:	false,		headerHeight: 50,
	uri:		location,		cellHeight:	0,				cellWidth: 0,			trackingMosaic: false,
	//UI
	//CORE
	domains:	[],				resolution: 4,				plane:	 	[],			planes: [[],[]],
	bands: 		[],				waves: 		[],				planarWaves:[],
	events:		[], /*ex turns*/beings:		[],				items:		[] }
	//CORE

//game in which ai may inhabit robot bodies of different gender in order to convince people to agree to mind control, later augmented control

// Imaginary quality: the real value v(i) of the imaginary part i equals i in masculinity but res-i in femininity. this value is experienced by those who share an origin, to some degree.

// Theology can be used to differentiate criteria for excellence but otherwise less relevant 

// interpretation of childhood: a location can be quantified before it's qualified, but it doesn't need to be quantified in order to identify it even if its origin is that of the other (of the same gender)

// genders quantify mediocrity similarly

// sego & ego acc: want?
// sego & ego prod: like? 
// sid & id acc: need?
// sid & id prod: mean?

// weak blocks generate value as response to stress reduction?

// SPACE
function signZ(n) { if(n===0 && (1/n)===-Infinity) { return -1; } else { return 1; }}
function initSpace() { var w; var s;
	for(var i=0; i<AL.planarWaves.length; i++) { 
		for(var r=1; r<=AL.planarWaves[i].resolution; r++) { w=AL.planarWaves[i]; s=signZ(w.Z);
			new SpaceWave(w, w.Z*s); }}}
// SPACE
// PLANE
function SpaceWave(w,Z) { this.domain = w.domain; this.resolution = w.resolution; this.rational = w.rational; this.abstract = w.abstract; this.X = w.X; this.Y = w.Y; this.Z = Z; AL.planarWaves.push(this); }
function createVersionPair(w) {
	var i = new SpaceWave(w,-0); var e = new SpaceWave(w,+0); AL.planes[0].push(i); AL.planes[1].push(e); }
function initPlanarWaves() { for(var i=0; i<AL.waves.length; i++) { createVersionPair(AL.waves[i]); }}
function interleavePlanes(p1,p2) {var ret=[]; for(var i=0; i<p1.length; i++) {ret.push(p1[i].concat(p2[i]));} return ret;}
function initRealPlane() { var r1 = interleavePlanes(AL.domains[0].plane,AL.domains[1].plane); var r2 = interleavePlanes(AL.domains[2].plane,AL.domains[3].plane); var ret=r1.concat(r2); AL.plane=ret; }
function initDomainPlanes() { var buffer; var p; var d; var res;
	for(var i=0; i<AL.domains.length; i++){ d = AL.domains[i];
		for(var r=1;r<=AL.resolution;r++) { p = []; d.plane.push([]);
			for(var y=0; y<=r*2; y++) {buffer = []; p.push([]);
				for(var x=0; x<=r*2; x++) {
					if(y<r && x<r){		 buffer.push(d.sub.waves[r-1][r-y][r-x]); }
					else if(y<r && x>r){ buffer.push(d.obj.waves[r-1][r-y][x-r]); }
					else if(y>r && x<r){ buffer.push(d.cul.waves[r-1][y-r][r-x]); }
					else if(y>r && x>r){ buffer.push(d.log.waves[r-1][y-r][x-r]); }
					else if(y==r && x<r){buffer.push(d.F.waves[r-1][r-x]); }
					else if(y==r && x>r){buffer.push(d.S.waves[r-1][x-r]); }
					else if(y<r && x==r){buffer.push(d.T.waves[r-1][y-x]); }
					else if(y>r && x==r){buffer.push(d.N.waves[r-1][x-y]); }
					else if(y==r && x==r){buffer.push(d.wave); }}
				p[p.length].push(buffer); }
			d.plane[d.plane.length].push(p); }} colorAreaWaves(); }
function initPlanes() { initDomainPlanes(); initRealPlane(); initPlanarWaves(); }
// PLANE
// X is frequency, Y is amplitude, V or value is volume, locations are waves
// origins can overflow. one can adjust amplitude of origins in general, affecting all vectors of that origin
// WAVE
function initScalarWaves(d,r,b) { console.log("initScalarWaves(b): "); console.log(b); var halt=findScalarBand(d,r,b); if(!halt) { r--; m=b.scalar;
	var F=new ScalarWave(false,false,d,r,b.F);var S=new ScalarWave(false,true,d,r,b.S);
	var T=new ScalarWave(true,false,d,r,b.T); var N=new ScalarWave(true,true,d,r,b.N);
	d.F.waves[r][m]=F; d.S.waves[r][m]=S; d.T.waves[r][m]; d.N.waves[r][m]; }}
function ScalarWave(d,r,c) { this.name=nameWave(d,r,c);this.domain=d;this.resolution=r+1;this.color=colorScalarWave(d,r,c);
	var n = normaliseWave(d,r,c); this.rational = n.X; this.abstract = n.Y; this.X=c.X; this.Y=c.Y;
	
		//grxy
		AL.waves.push(this); }
function nameWave(d,r,c) { console.log("nameWave(c): "); console.log(c); if(!(d.g && !d.o)) { c = normaliseWave(d,r,c); } c.X=Math.abs(c.X)-1; c.Y=Math.abs(c.Y)-1;
	var names; if(r == 3) { if(c.X != 0 && c.Y != 0) { if(c.X < 0 && c.Y < 0) { names = [
	["belief",	"like",		"motive",	"peace"],
	["worry",	"love",		"style",	"can"],
	["detach",	"burden",	"happy",	"fun"],
	["dysphoria","defeat",	"fake",		"euphoria"]]; } else if(c.X < 0 && c.Y > 0) { names = [
	["norm",	"want",		"identity",	"innocence"],
	["greed",	"culture",	"join",		"could"],
	["hate",	"avoid",	"freedom",	"event"],
	["destroy",	"confusion","apathy",	"beauty"]]; } else if(c.X > 0 && c.Y < 0) { names = [
	["body",	"need",		"tool",		"method"],
	["pain",	"life",		"order",	"should"],
	["shame",	"problem",	"social",	"right"],
	["failure",	"loss",		"wrong",	"success"]]; } else if(c.X > 0 && c.Y > 0) { names = [
	["form",	"meaning",	"kind",		"reason"],
	["exclude",	"purpose",	"use",		"would"],
	["impose",	"reject",	"metalevel","connect"],
	["madness",	"deceive",	"disconnect","wisdom"]]; } return names[c.Y][c.X];}}
	else if(!(c.X==0 && c.Y==0)) { var m = Math.max(c.X,c.Y); if(X<0){ names = [
	"typical feeling",  "stereotypical feeling",  "special feeling",  "ideal feeling"  ];} else if(Y<0) { names = [
	"typical sensation","stereotypical sensation","special sensation","ideal sensation"];} else if(X>0) { names = [
	"typical thinking", "stereotypical thinking", "special thinking", "ideal thinking" ];} else if(Y>0) { names = [
	"typical intuition","stereotypical intuition","special intuition","ideal intuition"];} return names[m]; } else {
	if(!d.gender && !d.other) { return "feminine self"; } else if(d.gender && !d.other) { return "masculine self"; }
	else if(d.gender && d.other) { return "masculine other"; } else if(!d.gender && d.other) { return "feminine other"; }}}
function judgeWave(X,Y) { X=Math.abs(X); Y=Math.abs(Y); if(Y>X) { return true; } else { return false; }}
function normaliseWave(d,r,c) { var n={ X:c.X, Y:c.Y }; var B=judgeWave(c.X,c.Y); 
	if(!d.g) { if(B) { n.X=c.X; n.Y=c.Y; } else { n.X=c.Y; n.Y=c.X; }}
	if(!d.g && !d.o) { if ( n.X * n.Y < 0 ) { n.X= -n.X; n.Y= -n.Y; }}
	else if(!d.g && d.o){if(n.X * n.Y > 0 ) { n.X= -n.X; n.Y= -n.Y; }}
	else if(d.g && d.o) { n.X = -n.X; n.Y = -n.Y; } return n; }
function Wave(rational,abstract,d,r,c) { this.name = nameWave(d,r,c); this.domain=d; this.resolution=r+1; //when color?
	this.rational=rational; this.abstract=abstract; this.X=c.X; this.Y=c.Y; AL.waves.push(this); }
function initWaves(d,r,b,x,y) { var halt=findBand(d,r,b); if(!halt) { r--; //oli vähä vaikee toi r--
	var sub=new Wave(false,false,d,r,b.sub);var cul=new Wave(false,true,d,r,b.cul);
	var obj=new Wave(true,false,d,r,b.obj);	var log=new Wave(true,true,d,r,b.log);
	d.sub.waves[r][y][x]=sub; d.cul.waves[r][y][x]=cul;	d.obj.waves[r][y][x]=obj; d.log.waves[r][y][x]=log; }}
// WAVE
// substitute normalisation by rat / abs?
// metaevil = man behaves like a woman when only men can notice. this conditioning is probably difficult to sustain. only a robot can do it. ability to conduct and sustain metaevil is especially effective for weakening F type buddhas
// BAND
// qualify gender first, then otherness (in truth tables, like in colors already)
function qualifyScalarBand(d,r,m) { var b={F:{X:0,Y:0},S:{X:0,Y:0},T:{X:0,Y:0},N:{X:0,Y:0}}; 
	if(!d.g && !d.o) 	 { b.N.X= -m; b.N.Y = 0; b.T.X = 0; b.T.Y= -m; b.S.X = m; b.S.Y = 0; b.F.X = 0; b.F.Y = m; }
	else if(d.g && !d.o) { b.F.X= -m; b.F.Y = 0; b.S.X = 0; b.S.Y= -m; b.T.X = m; b.T.Y = 0; b.N.X = 0; b.N.Y = m; }
	else if(!d.g && d.o) { b.S.X= -m; b.S.Y = 0; b.F.X = 0; b.F.Y= -m; b.N.X = m; b.N.Y = 0; b.T.X = 0; b.T.Y = m; }
	else if(d.g && d.o)  { b.T.X= -m; b.T.Y = 0; b.N.X = 0; b.N.Y= -m; b.F.X = m; b.F.Y = 0; b.S.X = 0; b.S.Y = m; }
	return b; }
function ScalarBand(d,r,m,x,y) { var g=d.gender; var o=d.other;
	var vol=quantifyBand(g,r,x,y); this.vol=vol; var q=qualifyScalarBand(d,r,m); this.scalar=m;
	var F={X:q.F.X,y:q.F.Y}; var S={X:q.S.X,y:q.S.Y}; var T={X:q.T.X,y:q.T.Y}; var N={X:q.N.X,y:q.N.Y};
	this.F=F; this.S=S; this.T=T; this.N=N; this.gender=g; this.other=o; this.resolution=r; }
function findScalarBand(d,r,b) { var b=d.scalarBands[r]; for(var i = 0; i<d.scalarBands[r]; i++) {
	if(b[i].F || b[i].S || b[i].T || b[i].N) { return b[i]; } else return null; }}
function findBand(d,r,b) { var b=d.bands[r]; for(var i = 0; i<d.bands[r]; i++) {
	if(b[i].sub || b[i].cul || b[i].obj || b[i].log) { return b[i]; } else return null; }}
function qualifyBand(d,r,x,y) { var b={ x:0,y:0,sub:{X:0,Y:0},cul:{X:0,Y:0},obj:{X:0,Y:0},log:{X:0,Y:0}};
	if(!d.g) { if(x<=y) { b.x=y; b.y=x; } b.x=r-b.x; b.y=r-b.y; } else { b.x=x; b.y=y; }	if(!d.g && !d.o) {
		b.sub.X= -b.x;b.sub.Y= -b.y;b.cul.X = b.x;b.cul.Y = b.y;b.obj.X = b.x;b.obj.Y = b.y;b.log.X= -b.x;b.log.Y= -b.y;} 
	else if(d.g && !d.o) {
		b.sub.X = b.x;b.sub.Y = b.y;b.cul.X = b.x;b.cul.Y = b.y;b.obj.X = b.x;b.obj.Y = b.y;b.log.X = b.x;b.log.Y = b.y;}
	else if(!d.g && !d.o) {
		b.sub.X = b.x;b.sub.Y = b.y;b.cul.X= -b.x;b.cul.Y= -b.y;b.obj.X= -b.x;b.obj.Y= -b.y;b.log.X = b.x;b.log.Y = b.y;}
	else if(d.g && d.o) {
		b.sub.X= -b.x;b.sub.Y= -b.y;b.cul.X= -b.x;b.cul.Y= -b.y;b.obj.X= -b.x;b.obj.Y= -b.y;b.log.X= -b.x;b.log.Y= -b.y;}
	return b; }
function quantifyBand(g,r,x,y) {
	console.log("quantifyBand(grxy): ");
	console.log(g);
	console.log(r);
	console.log(x);
	console.log(y);
	var v; var R = r+1; if(x >= y) { v = y; if(!g) { v = R-x; }} else { v = x-y; } console.log("v: "); console.log(v); return v; }
function Band(d,r,x,y) { var g = d.gender; var o = d.other; var X = x+1; var Y = y+1;
	this.gender=g;this.other=o;this.resolution=r;this.x=x;this.y=y;
	var val = quantifyBand(g,r,X,Y); this.val = val; var q = qualifyBand(d,r,X,Y); //from the viewpoint of masculine self
	var sub = { X: q.sub.X, Y: q.sub.Y }; var cul = { X: q.cul.X, Y: q.cul.Y }; //need to normalise for other viewpoints?
	var obj = { X: q.obj.X, Y: q.obj.Y }; var log = { X: q.log.X, Y: q.log.Y };
	this.sub=sub; this.cul=cul; this.obj=obj; this.log=log; }
function initBands(){ var buffer; var band; var bands; var d; var res; var b; var zb;
	for(var i=0;i<AL.domains.length;i++) { bands=[]; scalarBands=[]; res=1; d=AL.domains[i];
		zb = new ScalarBand(d,0,0,0,0);
		for(var r=1;r<=AL.resolution;r++) { band=[]; scalarBand=[];
			for(var y=0;y<res;y++) { buffer=[]; zBuffer=[];
				zb = new ScalarBand(d,r,y,x,y); initScalarWaves(d,r,zb);
				for(var x=0; x<res; x++) {
					b = new Band(d,r,x,y); buffer.push(b); initWaves(d,r,b,x,y); }
				band.push(buffer); }
			if(res<AL.resolution) { bands.push(band); res++; } else { break; }}
		bands.push(band); d.bands=bands; }}
// "waveforms" are waveforms and in final application there should also be a "signal".
// BAND 
// interpreting intuition Ni, manifesting intuition Ne
// COLOR
// #aeff00 neon green blend for bad imaginary quality, #ffd000 for good? or blend to white or black?
function colorAreaRow(wa,w1,w2) { blendColors(wa.length+2,w1.color,w2.color);
	for(var i=0; i<wa.length;i++) { if(typeof wa[i].color == "undefined") {}}}
function colorAreaWaves() { var d; var w; var w1=null; var w2=null; var halt1; var halt2; var c1; var c2; var wa=[];
	for(var i=0; i<AL.domains.length; i++) { d=AL.domains[i];
		for(var r=0; r<AL.resolution; r++) {
			for(var y=0; y<AL.resolution; y++) {
				for(var x=0; x<AL.resolution; x++) { w = d.plane[r][y][x];
					if(halt1) { halt2 = isThresholdWave(w); } else { halt1 = isThresholdWave(w); }
					if(halt2) { colorAreaRow(wa,w1,w2); w1=null; w2=null; wa=[]; } else { wa.push(w); }}}}}}
function isThresholdWave(w) { var x=Math.abs(w.X); var y=Math.abs(w.Y);	if((x != 0 && y != 0) && x===1 || y===1 || x===AL.resolution || y===AL.resolution || x===y || x===y-1){ return true; } else { return false; }}
function colorScalarWave(d,r,c) { var ret; c.X=Math.abs(c.X); c.Y=Math.abs(c.Y); var m=Math.max(c.X,c.Y);
	if		(c.X<0){ ret=d.colors.F[r][m]; }else if(c.Y<0){ ret=d.colors.S[r][m]; }
	else if (c.X>0){ ret=d.colors.T[r][m]; }else if(c.Y>0){ ret=d.colors.N[r][m]; } return ret;}
function createScalarPalettes(d) { var v; var c={ F:[], S:[], T:[], N:[],
	lowF:{r:0,g:0,b:0,h:""},highF:{r:0,g:0,b:0,h:""}, lowS:{r:0,g:0,b:0,h:""},highS:{r:0,g:0,b:0,h:""},
	lowT:{r:0,g:0,b:0,h:""},highT:{r:0,g:0,b:0,h:""}, lowN:{r:0,g:0,b:0,h:""},highN:{r:0,g:0,b:0,h:""}};
	if(d.gender) {
		v=blendColors(3,d.cul.colors.lowB, d.sub.colors.lowB)[1]; if(d.other){ c.lowT=v;  }else{ c.lowF=v; }
		v=blendColors(3,d.sub.colors.lowB, d.obj.colors.lowB)[1]; if(d.other){ c.lowN=v;  }else{ c.lowS=v; }
		v=blendColors(3,d.obj.colors.lowB, d.log.colors.lowB)[1]; if(d.other){ c.lowF=v;  }else{ c.lowT=v; }
		v=blendColors(3,d.log.colors.lowB, d.cul.colors.lowB)[1]; if(d.other){ c.lowS=v;  }else{ c.lowN=v; }
		v=blendColors(3,d.cul.colors.highB,d.sub.colors.highB)[1];if(d.other){ c.highT=v; }else{ c.highF=v;}
		v=blendColors(3,d.sub.colors.highB,d.obj.colors.highB)[1];if(d.other){ c.highN=v; }else{ c.highS=v;}
		v=blendColors(3,d.obj.colors.highB,d.log.colors.highB)[1];if(d.other){ c.highF=v; }else{ c.highT=v;}
		v=blendColors(3,d.log.colors.highB,d.cul.colors.highB)[1];if(d.other){ c.highS=v; }else{c.highN=v;}}
	else{
		v=blendColors(3,d.cul.colors.highB,d.log.colors.highB)[1];if(d.other){ c.lowT=v;  }else{ c.lowF=v; }
		v=blendColors(3,d.log.colors.highB,d.obj.colors.highB)[1];if(d.other){ c.lowN=v;  }else{ c.lowS=v; }
		v=blendColors(3,d.obj.colors.highB,d.sub.colors.highB)[1];if(d.other){ c.lowF=v;  }else{ c.lowT=v; }
		v=blendColors(3,d.sub.colors.highB,d.cul.colors.highB)[1];if(d.other){ c.lowS=v;  }else{ c.lowN=v; }
		v=blendColors(3,d.cul.colors.farB,d.log.colors.farB)[1];  if(d.other){ c.highT=v; }else{ c.highF=v;}
		v=blendColors(3,d.log.colors.farB,d.obj.colors.farB)[1];  if(d.other){ c.highN=v; }else{ c.highS=v;}
		v=blendColors(3,d.obj.colors.farB,d.sub.colors.farB)[1];  if(d.other){ c.highF=v; }else{ c.highT=v;}
		v=blendColors(3,d.sub.colors.farB,d.cul.colors.farB)[1];  if(d.other){ c.highS=v; }else{c.highN=v;}}
	for(var r = 1; r <= AL.resolution; r++) {
		v=blendColors(r,c.lowF,c.highF); c.F.push(v); v=blendColors(r,c.lowS,c.highS); c.S.push(v);
		v=blendColors(r,c.lowT,c.highT); c.T.push(v); v=blendColors(r,c.lowN,c.highN); c.N.push(v);} return c; }
function componentToH(n) { var hex = n.toString(16); return hex.length == 1 ? "0" + hex : hex; }
function rgbToH(r,g,b) { if(r != null) { return "#"+componentToH(r)+componentToH(g)+componentToH(b); } else { return ""; }}
function hToRgb(hex) { var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex); return result ? {
	r: parseInt(result[1], 16), g: parseInt(result[2], 16), b: parseInt(result[3], 16) } : null; }
function blendColors(n,from,to) { var ret = [];
	var r = chunkify(n, from.r, to.r); var g = chunkify(n, from.g, to.g); var b = chunkify(n, from.b, to.b);
	for(var i = 0; i < n; i++) { h = rgbToH(r[i],g[i],b[i]); ret.push({r:r[i],g:g[i],b:b[i],h:h}); } return ret; }
function chunkify(n,from,to) { var ret = []; var size = Math.floor((to-from) / (n-1)); if(n % 2 == 0) {
	for(var i = 0; i < n; i++) { ret.push(from + (i * size)); } return ret; } else { ret = [from];
	for(var i = 1; i < (n-1); i++) { ret.push(from + (i * size)); }} ret.push(to); return ret; }
function createPalette(d,lowBh,lowGh,farBh,farGh,highBh,highGh) { var j; var c ={ // 'a' means array. why wasn't j declared?
	lowB: {r:0,g:0,b:0,h:"",a:[]}, lowG:{r:0,g:0,b:0,h:"",a:[]}, farB:{r:0,g:0,b:0,h:"",a:[]}, farG:{r:0,g:0,b:0,h:"",a:[]},
	highB:{r:0,g:0,b:0,h:"",a:[]}, highG:{r:0,g:0,b:0,h:"",a:[]}}; this.color = c;
	if(d.gender){ c.lowB.h=lowBh;c.lowG.h=lowGh;c.farB.h=farBh;c.farG.h=farGh;c.highB.h=highBh;c.highG.h=highGh; }
	else 		{ c.lowB.h=highBh;c.lowG.h=farGh;c.farB.h=highBh;c.farG.h=farGh;c.highB.h=farBh;c.highG.h=lowGh; } var v;
	v=hToRgb(lowBh); c.lowB.r=v.r; c.lowB.g=v.g; c.lowB.b=v.b; v=hToRgb(lowGh); c.lowG.r=v.r; c.lowG.g=v.g; c.lowG.b=v.b;
	v=hToRgb(farBh); c.farB.r=v.r; c.farB.g=v.g; c.farB.b=v.b; v=hToRgb(farGh); c.farG.r=v.r; c.farG.g=v.g; c.farG.b=v.b;
	v=hToRgb(lowBh);c.highB.r=v.r;c.highB.g=v.g;c.highB.b=v.b;v=hToRgb(highGh);c.highG.r=v.r;c.highG.g=v.g;c.highG.b=v.b;
	for(var i = 1; i <= AL.resolution; i++) { j=i-1;c.lowB.a[j]=blendColors(i,c.lowB,c.farB);c.lowG.a[j]=blendColors(i,c.lowG,c.farG);c.farB.a[j]=blendColors(i,c.farB,c.highB); c.farG.a[j]=blendColors(i,c.farG,c.highG);c.highB.a[j]=blendColors(i,c.lowB,c.highB);c.highG.a[j]=blendColors(i,c.lowG,c.highG); } return c; }
function createPalettes(d) { var ret = [];
	ret.push(createPalette(d,"#BAFFCC","#FFBBD5","#1C8035","#44323E","#2EFF62","#FF00BF"));
	ret.push(createPalette(d,"#C87CFF","#FFFEBC","#48007E","#424100","#8900FE","#FFFE00"));
	ret.push(createPalette(d,"#B9CDFF","#FFDDBC","#00257F","#462300","#0043FF","#FF7700"));
	ret.push(createPalette(d,"#C87CFF","#FFFEBC","#48007E","#424100","#8900FE","#FFFE00")); return ret; }
function colorDomains() { var p; var xy; var xY; var Xy; var XY; var d;
	for(var i = 0; i < AL.domains.length; i++) { d = AL.domains[i]; p = createPalettes(d);
		if		(!d.other&& !d.gender) { d.sub.colors=p[3]; d.cul.colors=p[1]; d.obj.colors=p[2]; d.log.colors=p[0]; }
		else if (!d.other&& d.gender ) { d.sub.colors=p[0]; d.cul.colors=p[1]; d.obj.colors=p[2]; d.log.colors=p[3]; }
		else if (d.other && !d.gender) { d.sub.colors=p[0]; d.cul.colors=p[2]; d.obj.colors=p[1]; d.log.colors=p[3]; }
		else 							{d.sub.colors=p[3]; d.cul.colors=p[2]; d.obj.colors=p[1]; d.log.colors=p[0];}}
		createScalarPalettes(d); }
// COLOR
// DOMAIN
function qualifyDomain(gender,other,quadrants) { var w = []; var buffer;
	for(var y = 1; y <= AL.resolution; y++) { buffer=[]; for(var x = 0; x < y; x++) { buffer.push([]); } w.push(buffer); }
	var sub = { X:quadrants.sub.X, Y:quadrants.sub.Y, w:w }; var cul = { X:quadrants.cul.X, Y:quadrants.cul.Y, w:w };
	var obj = { X:quadrants.obj.X, Y:quadrants.obj.Y, w:w }; var log = { X:quadrants.log.X, Y:quadrants.log.Y, w:w };
	return { sub:sub, cul:cul, obj:obj, log:log }; }
function signDomain(gender,other) { var sub; var cul; var obj; var log; var F; var S; var T; var N; var ret;
	if	   (!gender && !other){sub={X:true,Y:true}; cul={X:false,Y:true}; obj={X:true,Y:false}; log={X:false,Y:false};
		N={X:-1,Y:0}; T={X:0,Y:-1}; S={X:1,Y:0}; F={X:0,Y:1}; }
	else if(!gender && other) {sub={X:false,Y:false}; cul={X:true,Y:false}; obj={X:false,Y:true}; log={X:true,Y:true};
		T={X:-1,Y:0}; N={X:0,Y:-1}; F={X:1,Y:0}; S={X:0,Y:1}; }
	else if(gender && !other) {sub={X:false,Y:false}; cul={X:false,Y:true}; obj={X:true,Y:false}; log={X:true,Y:true};
		F={X:-1,Y:0}; S={X:0,Y:-1}; T={X:1,Y:0}; N={X:0,Y:1}; }
	else					  {sub={X:true,Y:true}; cul={X:true,Y:false}; obj={X:false,Y:true}; log={X:false,Y:false};
		S={X:-1,Y:0}; F={X:0,Y:-1}; N={X:1,Y:0}; T={X:0,Y:1}; }
	ret = { sub:sub, cul:cul, obj:obj, log:log, F:F, S:S, T:T, N:N }; return ret; }
function Domain(gender,other) { var signs = signDomain(other,gender); this.planes = [];
	var quadrants = qualifyDomain(gender,other,signs);
	this.bands = []; this.scalarBands = []; this.other=other; this.gender=gender;
	this.sub=quadrants.sub; this.cul=quadrants.cul; this.obj=quadrants.obj; this.log=quadrants.log;
	this.F=signs.F; this.S=signs.S; this.T=signs.T; this.N=signs.N; AL.domains.push(this); }
function initDomains() { new Domain(false,false,false); new Domain(false,true,false); new Domain(true,false,false); new Domain(true,true,false); colorDomains(); }

function initMetaphysics() { initDomains(); initBands(); console.log(AL.domains); initPlanes(); console.log(AL.planes); initSpace(); }

/*5{[1}\+!&8pS49h5&J                   X XXX
EE5^~*^!!!_XX46L35ur   XYX XX  XXX XYX X H
EBEVrr^\/\-JS4h&vovr    X   XX  X   X  XDQNX
EEQ}r>+*\;^4493ontjj    X   X X X   X   /T\X
QQHKj;^+;|x&5oTujjj}    X   X  XX   X  XXX|X
J5u53r^^\+/\cjj>>"\;    X   X   X   X   | |
j52xLJl}|\"}}{".` !^   XXX XXX XXX XXX  XXX
JT5555nr[r?1>[?{+;*/
function init() { initMetaphysics(); initUI(); displayTab(AL.tab); }

function initUI() { initTabs(); initControls(); }
function initControls() { window.addEventListener("resize", AL.tab.funcs.init, true); }
function initTabs() { for(var i = 0; i < AL.tabs.length; i++) { AL.tabs[i] = initTab(AL.tabs[i]); }}
function initTab(handle) { var label; var parameters; var demo; var code; var dev; var funcs;
	if(handle == "mosaic") { label = "Mosaic";
		parameters = { stereo: false,
			displayLeft: { xDim:"X", yDim:"Y", domain:{other:false,version:false,gender:false}, cellWidth:0, cellHeight:0,
				xRes:AL.xRes, yRes:AL.yRes, xPos:AL.xRes/2, yPos:AL.yRes/2 },
			displayRight:{ xDim:"Z", yDim:"Y", domain:{other:false,version:false,gender:false}, cellWidth:0, cellHeight:0,
				xRes:AL.xRes, yRes:AL.yRes, xPos:AL.xRes/2, yPos:AL.yRes/2 }};
		demo = [""];
		code = [
			"<div class='left half' id='leftPanelBack'>\
				<div class='absolute topLeft' id='leftPanelFront'></div>\
			</div>\
			<div class='right half' id='rightPanelBack'>\
				<div class='absolute topRight'id='rightPanelFront'></div>\
			</div>" ];
		dev  = [""];
		funcs = {
			init : function() { var t = AL.tab.parameters; createTabHTML(AL.tab);
				var windowWidth = window.innerWidth; var windowHeight = window.innerHeight;
				initMosaicDisplay(t,windowWidth,windowHeight);	initMosaicCanvases(t); },
			refresh : function() { var t = AL.tab.parameters;
				lookAtMosaic(t);
				refreshMosaicCanvas(t.displayLeft,"leftCanvas");
				refreshMosaicDOM(t.displayLeft,"leftPanelFront");
				if(t.stereo) {
					refreshMosaicCanvas(t.displayRight,"rightCanvas");
					refreshMosaicDOM(t.displayRight,"rightPanelFront"); }}}}
	var ret = new Tab(handle,parameters,label,demo,code,dev,funcs); return ret; }
function Tab(handle,parameters,label,demo,code,dev,funcs) { this.active = false; this.handle = handle; this.parameters = parameters; this.label = label; this.demo = demo; this.code = code; this.dev = dev; this.funcs = funcs; }
function getTabByHandle(handle) {
	for(var i = 0; i < AL.tabs.length; i++) { if(handle == AL.tabs[i].handle) { return AL.tabs[i]; }}}
function displayTab(handle) { AL.tab = getTabByHandle(handle); AL.tab.funcs.init(); }
function createTabHTML(tab) { var div = document.getElementById("content");
	for(var i = 0; i < Math.max(tab.demo.length,tab.code.length,tab.dev.length); i++) {
		if(typeof tab.demo[i] == "string") { div.innerHTML += tab.demo[i]; }
		if(typeof tab.code[i] == "string") { div.innerHTML += tab.code[i]; }
		if(typeof tab.dev[i] == "string") { div.innerHTML += tab.dev[i]; }}}
// TAB
// MOSAIC
function lookAtMosaic(t) { AL.mosaics = findMosaics(t); AL.tab.funcs.refresh(); }
function findMosaic(t) { var mosaicX = t.xPos-(AL.xRes/2); var mosaicY = t.yPos-(AL.yRes/2); var buffer = []; var ret = [];
	if(!t.version) { var p = AL.planes[0]; } else { var p = AL.planes[1]; }
	while(mosaicX < 0) { mosaicX += AL.xRes; } while(mosaicX >= AL.xRes) { mosaicX -= AL.xRes; }
	while(mosaicY < 0) { mosaicY += AL.yRes; } while(mosaicY >= AL.yRes) { mosaicY -= AL.yRes; }
	for(var x = mosaicX; x < mosaicX+t.xRes; x++) {
		for(var y = mosaicY; y < mosaicY+t.yRes; y++) {
			if(x < p[0].length) { if(y < p.length) { buffer.push(p[x][y]); } else { buffer.push(p[x][y-AL.yRes]); }}
			else if(y < p.length) { buffer.push(p[x-AL.xRes][y]); } else { buffer.push(p[x-AL.xRes][y-AL.yRes]); }}
		ret.push(buffer); } return ret; }
function findMosaics(t) { t.displayLeft.mosaicData = findMosaic(t.displayLeft);
	if(t.stereo) { t.displayRight.mosaicData = findMosaic(t.displayRight);}}
function initMosaicDisplay(t,windowWidth,windowHeight) {
	t.displayLeft.cellWidth = Math.floor(windowWidth / t.displayLeft.xRes);
	if(t.stereo) { t.displayLeft.cellwidth = Math.floor(t.displayLeft.cellWidth / 2);
		t.displayRight.cellWidth=Math.floor((windowWidth / t.displayRight.xRes) / 2);}			
	if(AL.demo) { t.displayLeft.cellHeight = Math.floor(windowHeight / t.displayLeft.yRes); }
	else if(!AL.devHeader) { t.displayLeft.cellHeight = Math.floor(windowHeight / t.displayLeft.yRes + 1); }
	else { t.displayLeft.cellHeight = Math.floor((innerHeight-AL.headerHeight) / t.displayLeft.yRes); }
	if(t.stereo) { if(AL.demo) { t.displayRight.cellHeight = Math.floor(windowHeight / t.displayRight.yRes); }
		else if(!AL.devHeader) { t.displayRight.cellHeight = Math.floor(windowHeight / t.displayRight.yRes + 1); }
		else { t.displayRight.cellHeight = Math.floor((innerHeight-AL.headerHeight) / t.displayRight.yRes); }}}
function initMosaicCanvases(t) { var rightBack;
	createMosaicCanvas(t.displayLeft,"left"); if(t.stereo) { createMosaicCanvas(t.displayRight,"right"); }
	else { rightBack = document.getElementById("rightPanelBack"); rightBack.style.display = "none"; }}
function createMosaicCanvas(t,id) { var div = document.getElementById(id + "PanelBack");
	var c = document.createElement("canvas"); c.id = id + "Canvas";
	c.width = t.cellWidth * t.xRes; c.height = t.cellHeight * t.yRes; div.appendChild(c); }
function refreshMosaicDOM(t,id) { var div = document.getElementById(id + "PanelFront");	var buffer = "";
	for(var x = 0; x < t.xRes; x++) { for(var y = 0; y < t.yRes; y++) { buffer +=
		"<div class='cell "+id+"' id='cell"+x+"-"+y+"' style='width:"+t.cellWidth+"px;height:"+t.cellHeight+"px'>\
			<div class='absolute topLeft cellBack'>" + x + "</div>\
			<div class='absolute topRight cellFront'>&nbsp;" + y + "</div>\
		</div>"; } buffer += "<br />"; } console.log(buffer); div.innerHTML = buffer; }
function refreshMosaicCanvas(t,id) { var canvas = document.getElementById(id);
	var c = canvas.getContext("2d",{alpha:false}); if(!t.version) {var p = AL.planes[0];} else {var p = AL.planes[1];}
	for(var y = 0; y < t.yRes; y++) { for(var x = 0; x < t.yRes; x++) {
		c.fillStyle = p[x][y].colorHex;	c.fillRect(x*t.cellWidth, y*cellHeight, t.cellWidth, t.cellHeight);	}}}
// MOSAIC
// Jesus was valued for showing poor people an example on how to behave like kings. But do kings behave well? And what about women?
// I have been told that there can't be an enemy of Islam that shall destroy Islam. But I haven't been told there can't be a friend or lover of Islam that shall metaphorically destroy Islam in certain places or contexts despite the fact that the numerous merits of Islam are obvious. If that entity should have a name then I'd consider calling that "Anti-Mahdi".
// WHAT IS GOD
// Why is this word in most languages "even though most people don't need it"?
// Why do most people understand what this means "even though most people don't believe in it?"
// Do people of current times think people of the old times gone understood God any better than they themselves do?
// Or did the people of the gone times merely believe in God?
		</script>
	</head>
	<body onload="init();">
		<div id="wrapper">
			<div id="header"></div>
			<div id="content"></div>
		</div>
	</body>
</html>
